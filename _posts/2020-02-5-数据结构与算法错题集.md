---
layout:     post
title:      数据结与算法
subtitle:   剑指Offer题集
date:       2020-02-5
author:     Gavyn
header-img: img/post-bg-git.jpg
catalog: true
tags:
    - 数据结构
    - C++
---

>来自剑指Offer上的题目

#运算符重载
（T1）请为下面的类类型添加赋值运算符函数
	class CMyString
	{
	private:
		char* m_pData;
	public:
		CMyString(char* pData = nullptr);
		CMyString(const CMyString& str);
		~CMyString();
		//CMyString & CMyString::operator=(const CMyString & str) 此处为后续加上的函数声明，下面的为函数实现。
	};

1.返回引用以便连续赋值（如果不是返回引用，①在形参是引用的前提下，第二次赋值左右类型不一致，无法完成赋值；②在形参不是引用的前提下，则每次赋值时都会调用赋值构造函数，消耗大量的资源）
2.传入常量引用：非引用的话，形参到实参会调用一次复制构造函数，产生无谓消耗（顶层const对拷贝无影响）
3.释放实例自身已有的内存
4.判断传入的参数和当前的实例（*this）是不是同一个实例。如果是，不进行赋值操作，否则释放内存的时候，传入参数的内存也被释放掉了（多个对象指向同一块儿内存，释放要小心！）

	CMyString & CMyString::operator=(const CMyString & str)
	{
		if (this == &str) //指向同一块儿内存
			return *this;
		delete[] m_pData;  //分配新内存之前应该释放自己的空间;
		m_pData = nullptr;

		m_pData = new char[strlen(str.m_pData) + 1];
		strcpy(m_pData, str.m_pData);
		return *this;
	}

运算符重载的基本知识
	一般形式：
      返回类型 operator 运算符(参数类型1 [,参数类型2] [,参数类型3] [, 参数类型N]);

	重载的运算符是具有特殊名字的函数：它们的名字是由关键字operator和其后要定义的运算符号共同组成。它与普通函数一样也有返回值、参数列表、以及函数体。
	重载运算符函数的参数数量与该运算符的作用的运算对象数量一样多。一元运算符有一个参数，二元运算符有两个。对于二元运算符来说，左侧运算对象传递给第一个参数，右侧运算对象传递给第二个参数。
	如果一个运算符函数是成员函数，则它的第一个(左侧)运算对象绑定到隐式的this指针上，因此，成员运算符函数的参数比运算符的运算对象少一个。

C++中delete和delete[]的区别
	C++告诉我们在回收用 new 分配的单个对象的内存空间的时候用 delete，回收用 new[] 分配的一组对象的内存空间的时候用 delete[]。[link]https://www.cnblogs.com/chucks123/p/7764449.html
	1. 删除单变量地址空间
	int *a = new int;
	delete a; //释放单个int的空间
	2. 删除数组空间
	int *a = new int[5];
	delete []a; //释放int数组空间

# 数组
（T4）在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。

	class Solution {
	public:
		bool Find(int target, vector<vector<int> > array) {  //vector<int>为存贮int型数字的一维数组；数组可以初始化VECTOR对象，反之则不行
			bool flag = false ;
			if (!array.empty()){    //访问序列时首先要判断序列是否为空；此处用while 则出现运行超时报错。不同点就是if没有循环的性质,一旦执行过后就跳出.此语句也可以为：if (array.size()!= 0)或者 if (array.begin() != array.end()) 
				int row = 0;
				int col = array[0].size()-1;	//此处若用array.size()-1,则编译不通过
				while (row <array[0].size() && col >= 0){ //变量合法性检查

					if (target < array[row][col])
						--col;
					else if (target > array[row][col])
						++row;
					else{
						flag = true;
						break;  //跳出while 循环
					}
				}
			 }
			return flag;
		}
	};

ps:每用到一个变量，应考虑其合法性。

# 字符串
请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。
